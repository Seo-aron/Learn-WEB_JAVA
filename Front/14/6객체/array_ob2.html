<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // 주제 : 배열 생성 및 요소 접근

    //fruits라는 배열 참조변수를 선언하고, 
    //"Apple","Banana","Cherry"라는 세개의 문자열을 요소로 가지는 배열을 할당합니다
    let fruits = ["Apple","Banana","Cherry"];
    //              0         1        2      index

    //fruits배열의 첫 번째 요소인 "Apple"을 얻어와 출력합니다.
    console.log(   fruits[0]  );


    //fruits배열에 저장된 요소의 총 갯수를 얻어 출력합니다.
    console.log( fruits.length );

    //let fruits = ["Apple","Banana","Cherry"];
    //              0         1        2      index

//배열에서 제공해주는 메소드 이용!!!!
    
    //배열 메모리의 가장 마지막 index2위치 뒤에 "Date"요소 추가
    fruits.push("Date"); // ["Apple","Banana","Cherry", "Date"];
                          //   0        1        2        3    index


    //배열 메모리의 가장 마지막 index3위치의 "Date"요소를 제거하고 그값을 반환해오자
    let value2 = fruits.pop();  //[  "Apple","Banana","Cherry" ];
                                //     0        1        2        index
    //반환한 "Date"요소를 출력
    console.log(value2);//"Date"

    //그리고 다시 fruits배열의 변화된 모습 출력!
    console.log(fruits);  // [  "Apple","Banana","Cherry" ];
                          //      0        1        2        index


    
    //배열 메모리의 가장 첫번째 저장된 "Apple"요소를 제거하고 그 값을 반환해오자
    //반환한 "Apple"요소를 출력
    //그리고 다시 fruits배열의 변화된 모습 출력!
    console.log(    fruits.shift()  );  //"Apple"
    console.log(fruits); //['Banana', 'Cherry']
                          //  0          1        index

    //배열 메모리의 0index위치 앞에(가장 앞위치에) "Avocado"를 추가합니다.
    //그리고 다시 fruits배열의 변화된 모습 출력!
    fruits.unshift("Avocado");  // ["Avocado", 'Banana', 'Cherry']
    //                                   0        1          2        index
    console.log(fruits);
    
 //  let fruits = ["Avocado", 'Banana', 'Cherry'];   <-현재 배열 모습
 //                     0        1          2      index
 
 // 반복 메소드 사용!
      //fruits배열 메모리에 저장된 각 요소를 차례대로 반복해서 얻어 출력!
      //단! forEach메소드 사용!

      //형태1. fruits.forEach(function(fruit){console.log(fruit);  });

      //형태2.
      //이 경우 각 요소를 console.log로 출력하므로 
      // "Avocado", "Banana", "Cherry"
      fruits.forEach( fruit =>   console.log(fruit) );
 //  let fruits = ["Avocado", 'Banana', 'Cherry'];   <-현재 배열 모습
 //                     0        1          2      index
 //반복 메서드2
     //map()메소드
     //- 배열의 각요소에 대해 주어진 콜백함수를 호출하고,
     //  그 결과로 새로운 배열을 생성해서 새로운 배열 자체를 반환하는 메소드 
     //- 이 메소드는 배열에 저장된 원본데이터를 변경하지 않고
     //   계산에 의해 새로운 배열에 넣어 새로운 배열 자체를 반환합니다. 
                                          //"Avocado", "Banana", 'Cherry'
     let upperFriuts  = fruits.map(function(fruit){
           //"Avocado".toUpperCase() ->  "AVOCADO" 
           //"Banana".toUpperCase() ->  "BANANA" 
           //"Cherry".toUpperCase() ->  "CHERRY"
           return  fruit.toUpperCase();  
           //새로운 배열 생성됨  ->   [   "AVOCADO",  "BANANA",  "CHERRY"  ]
     });

     console.log(upperFriuts); //[   "AVOCADO",  "BANANA",  "CHERRY"  ]  


     let upperFriuts2 = fruits.map( fruit =>   fruit.toUpperCase()    );

     console.log(upperFriuts2);


     //---------------------------
     //보충 map()메소드

     let numbers = [1, 2, 3, 4, 5]; 
     //             0  1  2  3  4  index

     //numbers배열 메모리에 저장되어 있는  모든 요소를 차례로 반복해서 얻어
     //  1요소 ->  1 * 1  -> 1         새로운배열 자동생성 [1]
     //  2요소 ->  2 * 2  -> 4                             [1,4]
     //  3요소 ->  3 * 3  -> 9                             [1,4,9]
     //  4요소 ->  4 * 4  -> 16                            [1,4,9,16]
     //  5요소 ->  5 * 5  -> 25                            [1,4,9,16,25]
     let newNumbers = numbers.map(function(number){  return number * number; });

     //일반 for반복문을 이용해 newNumbers배열에 저장된 요소들을 각각 차례로얻어출력
     for(let i=0;   i<newNumbers.length;  i++){

            console.log( newNumbers[i] );//1
                                         //4
                                         //9
                                         //16
                                         //25
     } 

     /*
     참고. map()

      let numbers2 = [1, 2, 3];
      //              0  1  2  index

      let context = { value: 'Hello' };

      let newNumbers2 = numbers2.map(function(number) {

          return this.value; // 현재 context 객체의 value를 반환
      
        }, context); //map메소드의 두번째 인자로 특정 객체의 속성값들을 얻어
                     //새로운 배열에 담아 새로운 배열을 반환할수있다.
                     

      console.log(newNumbers2); // ['Hello', 'Hello', 'Hello']

      */


 //  let fruits = ["Avocado", 'Banana', 'Cherry'];   <-현재 배열 모습
 //                     0        1          2      index

//배열객체가 제공하는 find()메소드

//조건에 맞는 요소찾기
     //배열의 요소 중 조건을 만족하는 첫 번째 요소를 반환합니다.
     //여기서는 요소가 "B"로 시작하는 첫 번째 과일을 찾기 위해
     //fruit.startsWith("B"); 조건검사 메소드를 호출한 것이다
     //'Banana'가  "B"로 시작하므로 조건을 만족하여 
     //조건에 만족한 'Banana'문자열을 반환해 줍니다. 
     let foundFruit = fruits.find( fruit => fruit.startsWith("B") );
     // 'Banana'



 //  let fruits = ["Avocado", 'Banana', 'Cherry'];   <-현재 배열 모습
 //                     0        1          2      index

      //배열에 저장된 일부 요소 추출해서 새로운배열로 만들어 반환
      //-> slice(index)메소드
      //   - 배열에 특정 부분을 잘라서 새로운 배열을 만들어 반환 하는 메소드 
      
      //여기서는 index 1부터 배열의 끝 index위치 까지의 데이터를 잘라서
      //[ 'Banana', 'Cherry' ] 자른 새로운 배열을 반환합니다.
      let someFruits = fruits.slice(1);

      console.log(someFruits);

  </script>


</body>
</html>